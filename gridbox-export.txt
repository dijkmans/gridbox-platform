===== FILE: /opt/gridbox-agent/agent.mjs =====
import fs from "fs";
import os from "os";
import https from "https";
import http from "http";
import jpeg from "jpeg-js";
import { execFileSync } from "child_process";

const CFG_PATHS = [
  "/opt/gridbox-agent/config.json",
  "/boot/firmware/gridbox-agent/config.json",
  "/boot/gridbox-agent/config.json"
];

const STATE_PATH = "/var/lib/gridbox-agent/state.json";
const sleep = (ms) => new Promise(r => setTimeout(r, ms));

function firstExisting(paths){
  for (const p of paths){
    try { if (fs.existsSync(p)) return p; } catch {}
  }
  return null;
}
function readJson(p){ return JSON.parse(fs.readFileSync(p, "utf8")); }
function writeJson(p, obj){
  try{
    fs.mkdirSync("/var/lib/gridbox-agent", { recursive: true });
    fs.writeFileSync(p, JSON.stringify(obj, null, 2), "utf8");
  } catch {}
}
function loadState(){
  try{
    const s = readJson(STATE_PATH);
    return { door: s?.door || "unknown" };
  } catch {
    return { door: "unknown" };
  }
}
function saveState(st){ writeJson(STATE_PATH, st); }

function readCfg(){
  const cfgPath = firstExisting(CFG_PATHS);
  let cfg = {};
  if (cfgPath) {
    try { cfg = readJson(cfgPath); } catch {}
  }

  cfg.apiBaseUrl = process.env.API_BASE || cfg.apiBaseUrl;
  cfg.boxId = process.env.BOX_ID || cfg.boxId;

  if (!cfg.apiBaseUrl || !cfg.boxId) {
    throw new Error("Configuratie incompleet: API_BASE en/of BOX_ID ontbreekt");
  }

  cfg.apiBaseUrl = String(cfg.apiBaseUrl).replace(/\/$/, "");

  cfg.pollMs = Number(process.env.POLL_MS || cfg.pollMs || 200);
  cfg.abortCheckMs = Number(process.env.ABORT_CHECK_MS || cfg.abortCheckMs || 100);

  cfg.openDurationMs = Number(process.env.OPEN_DURATION_MS || cfg.openDurationMs || 30000);
  cfg.closeDurationMs = Number(process.env.CLOSE_DURATION_MS || cfg.closeDurationMs || 30000);
  cfg.reverseDelayMs = Number(process.env.REVERSE_DELAY_MS || cfg.reverseDelayMs || 0);
  cfg.lightAfterCloseMs = Number(process.env.LIGHT_AFTER_CLOSE_MS || cfg.lightAfterCloseMs || 30000);

  cfg.device = cfg.device || {};
  cfg.device.deviceId = cfg.device.deviceId || os.hostname();
  cfg.device.agentName = cfg.device.agentName || "Gridbox Agent";

  cfg.hardware = cfg.hardware || {
    mode: "i2c",
    activeHigh: true,
    i2cBus: 1,
    i2cAddress: "0x10",
    openRelay: 1,
    closeRelay: 2,
    lightRelay: 3
  };

  cfg.camera = cfg.camera || {};
  cfg.camera.url = process.env.CAMERA_SNAPSHOT_URL || cfg.camera.url || "";
  cfg.camera.user = process.env.CAMERA_USER || cfg.camera.user || "";
  cfg.camera.pass = process.env.CAMERA_PASS || cfg.camera.pass || "";

  if (process.env.CAMERA_ENABLED != null) {
    cfg.camera.enabled = ["1", "true", "yes", "on"].includes(String(process.env.CAMERA_ENABLED).toLowerCase());
  } else {
    cfg.camera.enabled = (cfg.camera.enabled ?? !!cfg.camera.url);
  }

  cfg.camera.intervalSec = Number(process.env.CAMERA_INTERVAL_SEC || cfg.camera.intervalSec || 3);
  cfg.camera.postCloseSec = Number(process.env.CAMERA_POST_CLOSE_SEC || cfg.camera.postCloseSec || 30);

  cfg.camera.dedupe = cfg.camera.dedupe || {};
  cfg.camera.dedupe.enabled = (cfg.camera.dedupe.enabled ?? true);
  cfg.camera.dedupe.threshold = Number(process.env.CAMERA_DEDUPE_THRESHOLD || cfg.camera.dedupe.threshold || 3);
  cfg.camera.dedupe.minKeepMs = Number(process.env.CAMERA_DEDUPE_MIN_KEEP_MS || cfg.camera.dedupe.minKeepMs || 10000);
  cfg.camera.dedupe.maskBottomPct = Number(process.env.CAMERA_DEDUPE_MASK_BOTTOM_PCT || cfg.camera.dedupe.maskBottomPct || 0);

  cfg.__cfgPath = cfgPath || null;
  return cfg;
}

function requestJson(url, method = "GET", bodyObj = null){
  return new Promise((resolve) => {
    let u;
    try { u = new URL(url); } catch { return resolve({ ok: false, status: 0, json: null }); }

    const lib = (u.protocol === "https:") ? https : http;
    const body = bodyObj ? JSON.stringify(bodyObj) : null;

    const headers = { "Accept": "application/json" };
    if (body) {
      headers["Content-Type"] = "application/json";
      headers["Content-Length"] = Buffer.byteLength(body);
    }

    const req = lib.request({
      protocol: u.protocol,
      hostname: u.hostname,
      port: u.port || (u.protocol === "https:" ? 443 : 80),
      path: u.pathname + u.search,
      method,
      headers
    }, (res) => {
      let data = "";
      res.setEncoding("utf8");
      res.on("data", c => data += c);
      res.on("end", () => {
        let json = null;
        try { json = JSON.parse(data); } catch {}
        resolve({ ok: res.statusCode >= 200 && res.statusCode < 300, status: res.statusCode, json });
      });
    });

    req.on("error", () => resolve({ ok: false, status: 0, json: null }));
    if (body) req.write(body);
    req.end();
  });
}

function httpGetBuffer(url, user, pass){
  return new Promise((resolve) => {
    let u;
    try { u = new URL(url); } catch { return resolve({ ok: false, status: 0, buf: null }); }

    const lib = (u.protocol === "https:") ? https : http;

    const userFromUrl = u.username ? decodeURIComponent(u.username) : "";
    const passFromUrl = u.password ? decodeURIComponent(u.password) : "";
    const finalUser = user || userFromUrl;
    const finalPass = pass || passFromUrl;

    const headers = {};
    if (finalUser || finalPass) {
      const token = Buffer.from(`${finalUser}:${finalPass}`).toString("base64");
      headers["Authorization"] = `Basic ${token}`;
    }

    const req = lib.request({
      protocol: u.protocol,
      hostname: u.hostname,
      port: u.port || (u.protocol === "https:" ? 443 : 80),
      path: u.pathname + u.search,
      method: "GET",
      headers
    }, (res) => {
      const chunks = [];
      res.on("data", c => chunks.push(Buffer.isBuffer(c) ? c : Buffer.from(c)));
      res.on("end", () => {
        const buf = Buffer.concat(chunks);
        resolve({ ok: res.statusCode >= 200 && res.statusCode < 300, status: res.statusCode, buf });
      });
    });

    req.on("error", () => resolve({ ok: false, status: 0, buf: null }));
    req.end();
  });
}

function httpPostBinary(url, buf, headers){
  return new Promise((resolve) => {
    let u;
    try { u = new URL(url); } catch { return resolve({ ok: false, status: 0, json: null, body: "" }); }

    const lib = (u.protocol === "https:") ? https : http;
    const h = { ...headers, "Content-Length": Buffer.byteLength(buf) };

    const req = lib.request({
      protocol: u.protocol,
      hostname: u.hostname,
      port: u.port || (u.protocol === "https:" ? 443 : 80),
      path: u.pathname + u.search,
      method: "POST",
      headers: h
    }, (res) => {
      const chunks = [];
      res.on("data", c => chunks.push(Buffer.isBuffer(c) ? c : Buffer.from(c)));
      res.on("end", () => {
        const body = Buffer.concat(chunks).toString("utf8");
        let json = null;
        try { json = JSON.parse(body); } catch {}
        resolve({ ok: res.statusCode >= 200 && res.statusCode < 300, status: res.statusCode, json, body });
      });
    });

    req.on("error", () => resolve({ ok: false, status: 0, json: null, body: "" }));
    req.write(buf);
    req.end();
  });
}

function i2cSet(bus, addr, relay, value){
  try {
    execFileSync("i2cset", ["-y", String(bus), String(addr), String(relay), String(value)], { stdio: "ignore" });
  } catch (e) {
    console.error("[AGENT] i2cset FAIL", { bus, addr, relay, value, err: String(e?.message || e) });
  }
}

function makeHw(hw){
  const mode = String(hw.mode || "sim").toLowerCase();
  if (mode !== "i2c"){
    return { openOn(){}, closeOn(){}, motorsOff(){}, light(){} };
  }

  const bus = hw.i2cBus ?? 1;
  const addr = hw.i2cAddress ?? "0x10";
  if (hw.openRelay == null) throw new Error("hardware.openRelay ontbreekt");
  if (hw.closeRelay == null) throw new Error("hardware.closeRelay ontbreekt");

  const lightRelay = hw.lightRelay ?? 0;
  const activeHigh = hw.activeHigh !== false;
  const ON = activeHigh ? "0xFF" : "0x00";
  const OFF = activeHigh ? "0x00" : "0xFF";

  return {
    openOn(){ i2cSet(bus, addr, hw.openRelay, ON); },
    closeOn(){ i2cSet(bus, addr, hw.closeRelay, ON); },
    motorsOff(){
      i2cSet(bus, addr, hw.openRelay, OFF);
      i2cSet(bus, addr, hw.closeRelay, OFF);
    },
    light(on){
      if (!lightRelay) return;
      i2cSet(bus, addr, lightRelay, on ? ON : OFF);
    }
  };
}

function phaseBucket(phase){
  const p = String(phase || "").toLowerCase();
  if (p.includes("close")) return "close";
  return "open";
}

function dhashHexFromJpeg(buf, maskBottomPct = 0){
  try{
    const decoded = jpeg.decode(buf, { useTArray: true });
    const { width, height, data } = decoded;
    if (!width || !height || !data) return null;

    const effH = Math.max(1, Math.floor(height * (100 - maskBottomPct) / 100));
    const gx = 9;
    const gy = 8;

    function grayAt(ix, iy){
      const x = Math.floor(ix * (width - 1) / (gx - 1));
      const y = Math.floor(iy * (effH - 1) / (gy - 1));
      const idx = (y * width + x) * 4;
      const r = data[idx] || 0;
      const g = data[idx + 1] || 0;
      const b = data[idx + 2] || 0;
      return (r * 299 + g * 587 + b * 114) / 1000;
    }

    let bits = 0n;
    for (let y = 0; y < 8; y++){
      for (let x = 0; x < 8; x++){
        const left = grayAt(x, y);
        const right = grayAt(x + 1, y);
        bits = (bits << 1n) | (left > right ? 1n : 0n);
      }
    }
    return bits.toString(16).padStart(16, "0");
  } catch {
    return null;
  }
}

function hammingHex64(aHex, bHex){
  try{
    let x = BigInt("0x" + aHex) ^ BigInt("0x" + bHex);
    let c = 0;
    while (x){
      c += Number(x & 1n);
      x >>= 1n;
    }
    return c;
  } catch {
    return 999;
  }
}

async function main(){
  const cfg = readCfg();
  const hw = makeHw(cfg.hardware);

  const urlBox = `${cfg.apiBaseUrl}/api/boxes/${encodeURIComponent(cfg.boxId)}`;
  let { door } = loadState();
  let moving = false;

  function log(...a){ console.log(`[AGENT ${cfg.boxId}]`, ...a); }

  async function getDesired(){
    const r = await requestJson(urlBox, "GET");
    if (!r.ok) return null;
    const d = r.json?.box?.desired;
    if (d === "open" || d === "close") return d;
    return null;
  }

  async function getCommand(){
    const r = await requestJson(`${urlBox}/commands`, "GET");
    if (!r.ok) return null;
    if (!r.json) return null;
    if (!r.json.type || !r.json.commandId) return null;
    return r.json;
  }

  async function ackCommand(commandId){
    const r = await requestJson(`${urlBox}/commands/${encodeURIComponent(commandId)}/ack`, "POST", {});
    return r.ok;
  }

  async function getCaptureSession(sessionId){
    const r = await requestJson(
      `${cfg.apiBaseUrl}/api/boxes/${encodeURIComponent(cfg.boxId)}/capture/${encodeURIComponent(sessionId)}`,
      "GET"
    );
    if (!r.ok) return null;
    return r.json?.session || null;
  }

  async function startCaptureSession(intervalMs, postCloseMs){
    const r = await requestJson(
      `${cfg.apiBaseUrl}/api/boxes/${encodeURIComponent(cfg.boxId)}/capture/start`,
      "POST",
      { intervalMs, postCloseMs }
    );
    if (!r.ok) return null;
    return r.json?.sessionId || null;
  }

  async function uploadFrame(sessionId, seq, phase, jpgBuf){
    const frameUrl =
      `${cfg.apiBaseUrl}/api/boxes/${encodeURIComponent(cfg.boxId)}/capture/${encodeURIComponent(sessionId)}/frame`;

    const ts = new Date().toISOString();
    return await httpPostBinary(frameUrl, jpgBuf, {
      "Accept": "application/json",
      "Content-Type": "image/jpeg",
      "X-Seq": String(seq),
      "X-Phase": String(phase || "unknown"),
      "X-Timestamp": ts
    });
  }

  const camEnabled = cfg.camera?.enabled === true;
  const intervalMs = Math.max(500, Number(cfg.camera?.intervalSec ?? 3) * 1000);
  const postCloseMs = Math.max(0, Number(cfg.camera?.postCloseSec ?? 30) * 1000);

  const dedupeCfg = cfg.camera?.dedupe || {};
  const dedupeEnabled = (dedupeCfg.enabled === true);
  const dedupeThreshold = Math.max(0, Number(dedupeCfg.threshold ?? 3));
  const dedupeMinKeepMs = Math.max(0, Number(dedupeCfg.minKeepMs ?? 10000));
  const dedupeMaskBottomPct = Math.max(0, Math.min(90, Number(dedupeCfg.maskBottomPct ?? 0)));

  let lastHash = { open: null, close: null };
  let lastKeepAt = { open: 0, close: 0 };

  function decideSkip(phase, jpgBuf){
    if (!dedupeEnabled) return { skip: false, dist: null, hash: null, bucket: null };

    const b = phaseBucket(phase);
    const h = dhashHexFromJpeg(jpgBuf, dedupeMaskBottomPct);
    if (!h) return { skip: false, dist: null, hash: null, bucket: b };

    const now = Date.now();
    const prev = lastHash[b];

    if (prev && (now - lastKeepAt[b]) < dedupeMinKeepMs){
      const dist = hammingHex64(prev, h);
      if (dist <= dedupeThreshold){
        return { skip: true, dist, hash: h, bucket: b };
      }
      return { skip: false, dist, hash: h, bucket: b };
    }
    return { skip: false, dist: null, hash: h, bucket: b };
  }

  function markKept(bucket, hash){
    if (!bucket || !hash) return;
    lastHash[bucket] = hash;
    lastKeepAt[bucket] = Date.now();
  }

  const capture = {
    running: false,
    sessionId: null,
    seq: 1,
    phase: "open",
    timer: null,
    stopTimer: null,
    busy: false
  };

  function setPhase(p){ capture.phase = p; }

  function clearStopTimer(){
    if (capture.stopTimer){
      clearTimeout(capture.stopTimer);
      capture.stopTimer = null;
    }
  }
  function stopLoopTimer(){
    if (capture.timer){
      clearTimeout(capture.timer);
      capture.timer = null;
    }
  }

  function scheduleNextShot(delayMs){
    if (!capture.running) return;
    stopLoopTimer();
    capture.timer = setTimeout(async () => {
      if (!capture.running) return;

      if (capture.busy){
        scheduleNextShot(200);
        return;
      }

      capture.busy = true;
      try{
        const camUrl = cfg.camera?.url || "";
        if (!camUrl){
          log("FAIL: camera url ontbreekt");
          capture.seq += 1;
          return;
        }

        const snap = await httpGetBuffer(camUrl, cfg.camera?.user || "", cfg.camera?.pass || "");
        if (!snap.ok || !snap.buf || snap.buf.length < 100){
          log("FAIL: snapshot", { status: snap.status });
          capture.seq += 1;
          return;
        }

        const d = decideSkip(capture.phase, snap.buf);
        if (d.skip){
          log("SKIP: duplicate", { seq: capture.seq, phase: capture.phase, dist: d.dist });
          capture.seq += 1;
          return;
        }

        const r = await uploadFrame(capture.sessionId, capture.seq, capture.phase, snap.buf);
        if (r.ok){
          log("OK: uploaded", { seq: capture.seq, phase: capture.phase, dist: d.dist ?? null });
          if (d.bucket && d.hash) markKept(d.bucket, d.hash);
        } else {
          log("FAIL: upload", { status: r.status, body: (r.body || "").slice(0, 200) });
        }

        capture.seq += 1;
      } finally {
        capture.busy = false;
      }

      scheduleNextShot(intervalMs);
    }, Math.max(0, Number(delayMs) || 0));
  }

  async function startCaptureIfNeeded(){
    if (!camEnabled) return;
    if (capture.running) return;

    const sid = await startCaptureSession(intervalMs, postCloseMs);
    if (!sid){
      log("capture start mislukt");
      return;
    }

    capture.running = true;
    capture.sessionId = sid;
    capture.seq = 1;
    capture.busy = false;

    lastHash = { open: null, close: null };
    lastKeepAt = { open: 0, close: 0 };

    log("capture gestart", { sessionId: capture.sessionId, intervalMs, postCloseMs, dedupeEnabled });
    scheduleNextShot(0);
  }

  async function stopCaptureNow(){
    if (!capture.running) return;

    const stopUrl =
      `${cfg.apiBaseUrl}/api/boxes/${encodeURIComponent(cfg.boxId)}/capture/${encodeURIComponent(capture.sessionId)}/stop`;
    const r = await requestJson(stopUrl, "POST", {});
    log("capture stop", r.ok ? "ok" : "fail", r.status, r.json);

    capture.running = false;
    capture.sessionId = null;
    capture.seq = 1;
    capture.busy = false;

    stopLoopTimer();
    clearStopTimer();
  }

  function startMotor(dir){
    hw.motorsOff();
    if (dir === "open") hw.openOn();
    if (dir === "close") hw.closeOn();
  }

  function lightForState(){
    if (door === "open") hw.light(true);
    if (door === "closed") hw.light(false);
  }

  hw.motorsOff();
  lightForState();
  log("boot", { cfgPath: cfg.__cfgPath, door, camEnabled, intervalMs, postCloseMs });

  if (door === "open"){
    setPhase("open");
    await startCaptureIfNeeded();
  }

  async function handleTakePicture(cmd){
    if (!camEnabled) {
      log("take_picture genegeerd: camera.enabled = false");
      return;
    }

    const camUrl = cfg.camera?.url || "";
    if (!camUrl){
      log("take_picture fail: camera url ontbreekt");
      return;
    }

    let sessionId = cmd?.payload?.sessionId || null;
    if (!sessionId){
      sessionId = await startCaptureSession(500, 30000);
      if (!sessionId){
        log("take_picture fail: geen sessionId");
        return;
      }
    }

    const snap = await httpGetBuffer(camUrl, cfg.camera?.user || "", cfg.camera?.pass || "");
    if (!snap.ok || !snap.buf || snap.buf.length < 100){
      log("take_picture FAIL snapshot", { status: snap.status });
      return;
    }

    let seq = 1;
    const sess = await getCaptureSession(sessionId);
    if (sess && typeof sess.lastSeq === "number") seq = sess.lastSeq + 1;
    else if (sess && typeof sess.frameCount === "number") seq = sess.frameCount + 1;
    else seq = Math.floor(Date.now() / 1000);

    const phase = (door === "open") ? "open" : (door === "closed") ? "close" : "unknown";

    const r = await uploadFrame(sessionId, seq, phase, snap.buf);
    if (!r.ok){
      log("take_picture FAIL upload", { status: r.status, body: (r.body || "").slice(0, 200) });
      return;
    }

    const okAck = await ackCommand(cmd.commandId);
    log("take_picture OK", { sessionId, seq, ack: okAck });
  }

  async function followDesired(initial){
    moving = true;
    let dir = initial;

    hw.light(true);

    outer: while (true){
      log("motion start", dir);

      if (dir === "open"){
        clearStopTimer();
        setPhase("opening");
        await startCaptureIfNeeded();
      }

      if (dir === "close"){
        clearStopTimer();
        if (capture.running) setPhase("closing");
      }

      startMotor(dir);

      const end = Date.now() + (dir === "open" ? cfg.openDurationMs : cfg.closeDurationMs);

      while (Date.now() < end){
        await sleep(cfg.abortCheckMs);
        const d = await getDesired();
        if (d && d !== dir){
          log("desired changed", { from: dir, to: d });
          hw.motorsOff();
          if (cfg.reverseDelayMs > 0) await sleep(cfg.reverseDelayMs);
          dir = d;
          continue outer;
        }
      }

      hw.motorsOff();

      if (dir === "open"){
        door = "open";
        saveState({ door });
        hw.light(true);
        setPhase("open");
        log("klaar open");
        break;
      }

      if (dir === "close"){
        door = "closed";
        saveState({ door });
        log("klaar closed");

        if (capture.running){
          setPhase("post-close");
          clearStopTimer();
          capture.stopTimer = setTimeout(() => {
            stopCaptureNow().catch(() => {});
          }, postCloseMs);
        }

        const lightEnd = Date.now() + cfg.lightAfterCloseMs;
        while (Date.now() < lightEnd){
          await sleep(cfg.abortCheckMs);
          const d = await getDesired();
          if (d === "open"){
            log("desired changed during post-close", { to: "open" });
            dir = "open";
            continue outer;
          }
        }

        hw.light(false);
        break;
      }
    }

    moving = false;
  }

  let lastCmdId = null;

  while (true){
    await sleep(cfg.pollMs);

    const cmd = await getCommand();
    if (cmd?.type === "take_picture" && cmd.commandId && cmd.commandId !== lastCmdId){
      lastCmdId = cmd.commandId;
      log("ðŸ“¸ take_picture ontvangen", { commandId: cmd.commandId, sessionId: cmd?.payload?.sessionId || null });
      await handleTakePicture(cmd);
    }

    if (moving) continue;

    const d = await getDesired();
    if (!d) continue;
    if (d === "open" && door === "open") continue;
    if (d === "close" && door === "closed") continue;

    await followDesired(d);
  }
}

main().catch(e => {
  console.error("[AGENT] FATAAL", e);
  process.exit(1);
});

===== FILE: /opt/gridbox-agent/poller.mjs =====
(bestaat niet)

===== FILE: /etc/systemd/system/gridbox-agent.service =====
[Unit]
Description=Gridbox Agent
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
ExecStart=/usr/bin/node /opt/gridbox-agent/agent.mjs
WorkingDirectory=/opt/gridbox-agent
Restart=always
RestartSec=2
Environment=NODE_ENV=production
Environment=BOX_ID=gbox-001
Environment=API_BASE=https://gridbox-api-960191535038.europe-west1.run.app
Environment=CAMERA_SNAPSHOT_URL=http://admin:victoria1@192.168.10.100/cgi-bin/snapshot.cgi


[Install]
WantedBy=multi-user.target

===== FILE: /opt/gridbox-agent/desired.txt =====
(bestaat niet)

